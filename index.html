<!doctype html>
<html lang="en">
<head>
    <link rel="icon" type="image/png" href="favicon.ico">

<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Micro Tetris</title>
<style>
  :root{
    --bg:#0b1220; --panel:#0f1724; --accent:#00d1ff; --muted:#9aa4b2; --glass: rgba(255,255,255,0.03);
    --cell: 28px;
  }
  *{box-sizing:border-box}
  body{margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial; background:linear-gradient(180deg,#041022,#08122a); color:#e8f5ff; display:flex; min-height:100vh; align-items:center; justify-content:center;}
  .wrap{display:flex; gap:20px; align-items:flex-start; padding:28px;}
  .board-panel, .info {background:var(--panel); padding:18px; border-radius:12px; border:1px solid var(--glass); box-shadow: 0 10px 30px rgba(2,6,23,0.6);}
  canvas{display:block; background:linear-gradient(180deg,#071226,#042135); border-radius:6px; image-rendering:pixelated;}
  .info{width:260px}
  h1{margin:0 0 6px 0; font-size:18px}
  .muted{color:var(--muted); font-size:13px}
  .stat{display:flex; justify-content:space-between; margin:8px 0; font-weight:600}
  .next {width: var(--cell); height: calc(var(--cell) * 4); background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); display:flex; align-items:center; justify-content:center; border-radius:6px; margin:8px 0; padding:6px}
  .controls{font-size:13px; color:var(--muted); margin-top:10px}
  button{background:var(--accent); color:#031022; border:0; padding:8px 12px; border-radius:8px; font-weight:700; cursor:pointer}
  .row {display:flex; gap:8px; align-items:center; justify-content:space-between;}
  footer{margin-top:12px; font-size:12px; color:var(--muted)}
  .small{font-size:12px; color:var(--muted)}
</style>
</head>
<body>
  <div class="wrap">
    <div class="board-panel">
      <h1>Micro Tetris</h1>
      <div class="muted">Play, clear lines, level up!</div>
      <div style="height:12px"></div>
      <canvas id="board" width="280" height="560"></canvas>
      <div style="height:10px"></div>
      <div class="row">
        <div class="small">Score: <span id="score">0</span></div>
        <div class="small">Level: <span id="level">1</span></div>
        <div class="small">Lines: <span id="lines">0</span></div>
      </div>
      <div style="height:10px"></div>
      <div class="row">
        <button id="pauseBtn">Pause (P)</button>
        <button id="restartBtn">Restart (R)</button>
      </div>
    </div>

    <aside class="info">
      <div style="display:flex; align-items:center; justify-content:space-between;">
        <div>
          <div style="font-weight:700">Next</div>
          <div class="muted">Preview the upcoming tetromino</div>
        </div>
      </div>

      <div style="height:10px"></div>
      <div class="next" id="nextContainer">
        <canvas id="next" width="112" height="112" style="image-rendering:pixelated"></canvas>
      </div>

      <div style="height:8px"></div>
      <div class="muted">Controls</div>
      <div class="controls">
        ← / → : move<br>
        ↑ : rotate<br>
        ↓ : soft drop<br>
        Space : hard drop<br>
        P : pause<br>
        R : restart
      </div>
      <footer>Made for quick fun — push updates to your repo to iterate!</footer>
    </aside>
  </div>

<script>
(() => {
  // Grid size
  const COLS = 10;
  const ROWS = 20;
  const CELL = 28; // matches CSS --cell
  const canvas = document.getElementById('board');
  const ctx = canvas.getContext('2d');
  ctx.imageSmoothingEnabled = false;

  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');
  nctx.imageSmoothingEnabled = false;

  // UI elements
  const scoreEl = document.getElementById('score');
  const levelEl = document.getElementById('level');
  const linesEl = document.getElementById('lines');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');

  // Colors for pieces
  const COLORS = [
    null,
    '#00f0f0', // I
    '#0000f0', // J
    '#f0a000', // L
    '#f0f000', // O
    '#00f000', // S
    '#a000f0', // T
    '#f00000', // Z
  ];

  // Tetromino shapes (matrices)
  const TETROMINOS = {
    1: [[0,0,0,0],
        [1,1,1,1],
        [0,0,0,0],
        [0,0,0,0]], // I
    2: [[2,0,0],
        [2,2,2],
        [0,0,0]], // J
    3: [[0,0,3],
        [3,3,3],
        [0,0,0]], // L
    4: [[4,4],
        [4,4]], // O
    5: [[0,5,5],
        [5,5,0],
        [0,0,0]], // S
    6: [[0,6,0],
        [6,6,6],
        [0,0,0]], // T
    7: [[7,7,0],
        [0,7,7],
        [0,0,0]] // Z
  };

  // Game state
  let arena = createMatrix(COLS, ROWS);
  let player = {
    pos: {x:0,y:0},
    matrix: null,
    next: null,
    score: 0,
  };
  let dropCounter = 0;
  let dropInterval = 800; // ms (lower = faster)
  let lastTime = 0;
  let isPaused = false;
  let totalLines = 0;
  let level = 1;

  // Utils
  function createMatrix(w,h){
    const mat = [];
    for(let y=0;y<h;y++){
      mat.push(new Array(w).fill(0));
    }
    return mat;
  }

  function drawCell(x,y,color){
    const px = x * CELL;
    const py = y * CELL;
    ctx.fillStyle = color;
    ctx.fillRect(px + 1, py + 1, CELL - 2, CELL - 2);
    // subtle border
    ctx.strokeStyle = 'rgba(0,0,0,0.25)';
    ctx.strokeRect(px + 1, py + 1, CELL - 2, CELL - 2);
  }

  function drawMatrix(matrix, offset){
    for(let y=0;y<matrix.length;y++){
      for(let x=0;x<matrix[y].length;x++){
        const val = matrix[y][x];
        if(val){
          drawCell(x + offset.x, y + offset.y, COLORS[val]);
        }
      }
    }
  }

  function merge(arena, player){
    for(let y=0;y<player.matrix.length;y++){
      for(let x=0;x<player.matrix[y].length;x++){
        if(player.matrix[y][x]){
          arena[y + player.pos.y][x + player.pos.x] = player.matrix[y][x];
        }
      }
    }
  }

  function collide(arena, player){
    const m = player.matrix;
    for(let y=0;y<m.length;y++){
      for(let x=0;x<m[y].length;x++){
        if(m[y][x] !== 0 &&
           (arena[y + player.pos.y] && arena[y + player.pos.y][x + player.pos.x]) !== 0){
          return true;
        }
      }
    }
    return false;
  }

  function rotate(matrix, dir){
    // transpose
    for(let y=0;y<matrix.length;y++){
      for(let x=0;x<y;x++){
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if(dir > 0){
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  function playerRotate(dir){
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while(collide(arena, player)){
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if(Math.abs(offset) > player.matrix[0].length){
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
  }

  function playerDrop(){
    player.pos.y++;
    if(collide(arena, player)){
      player.pos.y--;
      merge(arena, player);
      sweep();
      spawn();
    }
    dropCounter = 0;
  }

  function hardDrop(){
    while(!collide(arena, player)){
      player.pos.y++;
    }
    player.pos.y--;
    merge(arena, player);
    sweep();
    spawn();
    dropCounter = 0;
  }

  function sweep(){
    let rowCount = 0;
    outer: for(let y = arena.length - 1; y >= 0; y--){
      for(let x = 0; x < arena[y].length; x++){
        if(arena[y][x] === 0){
          continue outer;
        }
      }
      // row is full
      const row = arena.splice(y,1)[0].fill(0);
      arena.unshift(row);
      rowCount++;
      y++; // recheck same row index after splice
    }
    if(rowCount > 0){
      const points = [0,40,100,300,1200]; // standard tetris scoring per cleared lines (0-4)
      player.score += points[rowCount] * level;
      totalLines += rowCount;
      level = Math.floor(totalLines / 10) + 1;
      dropInterval = Math.max(120, 800 - (level - 1) * 60); // speed up
      updateUI();
    }
  }

  function updateUI(){
    scoreEl.textContent = player.score;
    levelEl.textContent = level;
    linesEl.textContent = totalLines;
  }

  function spawn(){
    player.matrix = player.next || createPiece(randInt(1,7));
    player.next = createPiece(randInt(1,7));
    // center horizontally
    player.pos.y = 0;
    player.pos.x = Math.floor((COLS - player.matrix[0].length) / 2);
    if(collide(arena, player)){
      // game over -> reset
      reset();
    }
    drawNext();
  }

  function reset(){
    arena = createMatrix(COLS, ROWS);
    player.score = 0;
    totalLines = 0;
    level = 1;
    dropInterval = 800;
    player.next = createPiece(randInt(1,7));
    player.matrix = null;
    // small flash / message (we keep it subtle)
    updateUI();
    spawn();
  }

  function createPiece(type){
    const mat = TETROMINOS[type];
    // deep clone the matrix
    return mat.map(row => row.slice());
  }

  function randInt(min, max){ return Math.floor(Math.random() * (max - min + 1)) + min; }

  // draw everything
  function draw(){
    // clear canvas
    ctx.clearRect(0,0,canvas.width, canvas.height);
    // background grid
    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const val = arena[y][x];
        if(val){
          drawCell(x,y,COLORS[val]);
        } else {
          // faint grid lines
          ctx.fillStyle = 'rgba(255,255,255,0.02)';
          ctx.fillRect(x*CELL + 1, y*CELL + 1, CELL - 2, CELL - 2);
        }
      }
    }
    if(player.matrix){
      drawMatrix(player.matrix, player.pos);
    }
  }

  function drawNext(){
    const size = 4; // next preview grid 4x4
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    const scale = nextCanvas.width / (size * CELL);
    // draw centered
    const matrix = player.next || createPiece(1);
    const padX = Math.floor((size - matrix[0].length) / 2);
    const padY = Math.floor((size - matrix.length) / 2);
    // small background
    nctx.fillStyle = 'rgba(255,255,255,0.02)';
    nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
    for(let y=0;y<matrix.length;y++){
      for(let x=0;x<matrix[y].length;x++){
        const val = matrix[y][x];
        if(val){
          nctx.fillStyle = COLORS[val];
          const px = (x + padX) * CELL * scale;
          const py = (y + padY) * CELL * scale;
          const w = CELL * scale - 2;
          nctx.fillRect(px + 1, py + 1, w, w);
        }
      }
    }
  }

  // game loop
  function update(time = 0){
    if(isPaused){
      lastTime = time;
      requestAnimationFrame(update);
      return;
    }
    const delta = time - lastTime;
    lastTime = time;
    dropCounter += delta;
    if(dropCounter > dropInterval){
      playerDrop();
    }
    draw();
    requestAnimationFrame(update);
  }

  // Input handling
  document.addEventListener('keydown', event => {
    if(event.repeat) return;
    if(event.key === 'ArrowLeft'){
      player.pos.x--;
      if(collide(arena, player)) player.pos.x++;
    } else if(event.key === 'ArrowRight'){
      player.pos.x++;
      if(collide(arena, player)) player.pos.x--;
    } else if(event.key === 'ArrowDown'){
      playerDrop();
    } else if(event.key === 'ArrowUp'){
      playerRotate(1);
    } else if(event.code === 'Space'){
      event.preventDefault();
      hardDrop();
    } else if(event.key === 'p' || event.key === 'P'){
      togglePause();
    } else if(event.key === 'r' || event.key === 'R'){
      reset();
    }
  });

  pauseBtn.addEventListener('click', togglePause);
  restartBtn.addEventListener('click', reset);

  function togglePause(){
    isPaused = !isPaused;
    pauseBtn.textContent = isPaused ? 'Resume (P)' : 'Pause (P)';
    if(!isPaused) lastTime = performance.now();
  }

  // initialize
  function init(){
    // scale canvas to cell size
    canvas.width = COLS * CELL;
    canvas.height = ROWS * CELL;
    // set next canvas size to show 4x4 at CELL scale
    nextCanvas.width = CELL * 4;
    nextCanvas.height = CELL * 4;
    player.next = createPiece(randInt(1,7));
    spawn();
    updateUI();
    requestAnimationFrame(update);
  }

  // expose small API for pushing score etc (not used now)
  window.microTetris = { reset };

  init();
})();
</script>
</body>
</html>
